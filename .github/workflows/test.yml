name: Run Tests

on:
  push:
    branches: [ main, master ]
    paths:
      - 'Core/**'
      - 'Tools/**'
      - 'Handlers/**'
      - 'Helpers/**'
      - 'Results/**'
      - 'Tests/**'
      - 'Program.cs'
      - '*.csproj'
      - '*.sln'
      - 'test.ps1'
      - 'sonar-project.properties'
      - '.github/workflows/test.yml'
  pull_request:
    branches: [ main, master ]
    paths:
      - 'Core/**'
      - 'Tools/**'
      - 'Handlers/**'
      - 'Helpers/**'
      - 'Results/**'
      - 'Tests/**'
      - 'Program.cs'
      - '*.csproj'
      - '*.sln'
      - 'test.ps1'
      - 'sonar-project.properties'
      - '.github/workflows/test.yml'
  workflow_dispatch:
    inputs:
      run_evaluation_mode:
        description: 'Run evaluation mode test (without license)'
        required: false
        default: false
        type: boolean

jobs:
  test:
    runs-on: windows-latest

    env:
      ASPOSE_LIC: ${{ secrets.ASPOSE_LIC }}
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: 17
        distribution: 'zulu'

    - name: Cache SonarCloud packages
      uses: actions/cache@v4
      with:
        path: ~\sonar\cache
        key: ${{ runner.os }}-sonar
        restore-keys: ${{ runner.os }}-sonar

    - name: Cache SonarCloud scanner
      id: cache-sonar-scanner
      uses: actions/cache@v4
      with:
        path: .\.sonar\scanner
        key: ${{ runner.os }}-sonar-scanner
        restore-keys: ${{ runner.os }}-sonar-scanner

    - name: Install SonarCloud scanner
      if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
      shell: pwsh
      run: |
        New-Item -Path .\.sonar\scanner -ItemType Directory -Force
        dotnet tool update dotnet-sonarscanner --tool-path .\.sonar\scanner

    - name: Restore dependencies
      run: dotnet restore AsposeMcpServer.sln

    - name: Setup Aspose License
      if: env.ASPOSE_LIC != ''
      run: |
        # Security: GitHub Actions automatically masks secrets in logs
        # Note: For PRs from forks, secrets are not available (GitHub security feature)
        # Use $env:ASPOSE_LIC to avoid PowerShell string parsing issues with XML content
        $licensePath = "Aspose.Total.lic"
        $licenseContent = $env:ASPOSE_LIC
        if ([string]::IsNullOrWhiteSpace($licenseContent)) {
          Write-Host "Warning: ASPOSE_LIC secret is empty or not set (this is normal for PRs from forks)"
          exit 0
        }
        [System.IO.File]::WriteAllText($licensePath, $licenseContent)
        Write-Host "License file created at: $licensePath (content secured)"
        echo "ASPOSE_LICENSE_PATH=$licensePath" >> $env:GITHUB_ENV
      shell: pwsh
      continue-on-error: true

    - name: Begin SonarCloud Analysis
      if: env.SONAR_TOKEN != ''
      shell: pwsh
      run: |
        # Project key and organization must be passed via command line
        # Other settings are loaded from sonar-project.properties
        .\.sonar\scanner\dotnet-sonarscanner begin /k:"xjustloveux_aspose-mcp-server" /o:"xjustloveux" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.token="${{ secrets.SONAR_TOKEN }}"

    - name: Build Solution
      run: dotnet build AsposeMcpServer.sln --configuration Release --no-restore

    - name: Test with Coverage
      id: test
      run: |
        dotnet test Tests/AsposeMcpServer.Tests.csproj `
          --configuration Release `
          --no-build `
          --settings Tests/coverlet.runsettings `
          --collect "XPlat Code Coverage" `
          --logger "trx;LogFileName=test-results.trx" `
          --logger "console;verbosity=minimal"
      shell: pwsh
      continue-on-error: true
    
    - name: Check Test Results
      if: always() && steps.test.outcome == 'failure'
      run: |
        Write-Host "=== Test Execution Summary ===" -ForegroundColor Yellow
        Write-Host "Exit Code: $LASTEXITCODE" -ForegroundColor Yellow
        
        # Check if test results file exists
        $testResults = Get-ChildItem -Path . -Recurse -Filter "test-results.trx" -ErrorAction SilentlyContinue
        if ($testResults) {
          Write-Host "Test results file found: $($testResults.FullName)" -ForegroundColor Green
          # Try to extract failure information from TRX file if possible
          $trxContent = Get-Content $testResults.FullName -Raw -ErrorAction SilentlyContinue
          if ($trxContent -match 'outcome="Failed"') {
            Write-Host "Some tests failed. Check the test results artifact for details." -ForegroundColor Red
          }
        } else {
          Write-Host "No test results file found. Tests may have failed before completion." -ForegroundColor Red
        }
        
        # Check for coverage files
        $coverageFiles = Get-ChildItem -Path . -Recurse -Filter "coverage.cobertura.xml" -ErrorAction SilentlyContinue
        if ($coverageFiles) {
          Write-Host "Coverage files found: $($coverageFiles.Count)" -ForegroundColor Green
        } else {
          Write-Host "No coverage files found. Coverage collection may have failed." -ForegroundColor Yellow
        }
      shell: pwsh
    
    - name: Find Test Results
      if: always()
      run: |
        $testResults = Get-ChildItem -Path . -Recurse -Filter "test-results.trx" -ErrorAction SilentlyContinue
        if ($testResults) {
          Write-Host "Found test results files:"
          $testResults | ForEach-Object { Write-Host "  - $($_.FullName)" }
        } else {
          Write-Host "No test-results.trx file found"
        }
      shell: pwsh
      continue-on-error: true
    
    - name: Clean up license file before artifact upload
      if: always()
      run: |
        # Security: Remove license file before uploading artifacts to prevent accidental exposure
        if (Test-Path "Aspose.Total.lic") {
          Remove-Item "Aspose.Total.lic" -Force -ErrorAction SilentlyContinue
          Write-Host "License file removed for security"
        }
        # Also check for other license files in the root directory
        Get-ChildItem -Path . -Filter "*.lic" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
      shell: pwsh
      continue-on-error: true
    
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: '**/test-results.trx'
        if-no-files-found: ignore
        retention-days: 1
    
    - name: Install ReportGenerator
      run: dotnet tool install -g dotnet-reportgenerator-globaltool
    
    - name: Find Coverage Files
      id: coverage
      run: |
        $coverageFiles = Get-ChildItem -Path . -Recurse -Filter "coverage.cobertura.xml" -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($coverageFiles) {
          $relativePath = $coverageFiles.FullName.Replace((Get-Location).Path + '\', '').Replace('\', '/')
          Write-Host "Found coverage file: $relativePath"
          echo "coverage_file=$relativePath" >> $env:GITHUB_OUTPUT
          echo "has_coverage=true" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "No coverage file found"
          echo "has_coverage=false" >> $env:GITHUB_OUTPUT
        }
      shell: pwsh
      continue-on-error: true
    
    - name: Generate Coverage Report
      if: steps.coverage.outputs.has_coverage == 'true'
      run: |
        $coverageFile = "${{ steps.coverage.outputs.coverage_file }}"
        $reportDir = "${{ runner.temp }}/CoverageReport"
        New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
        Write-Host "Generating coverage report from: $coverageFile"
        reportgenerator `
          -reports:"$coverageFile" `
          -targetdir:"$reportDir" `
          -reporttypes:"Html;Cobertura"
      continue-on-error: true
    
    - name: Upload Coverage Report to Codecov
      if: steps.coverage.outputs.has_coverage == 'true'
      uses: codecov/codecov-action@v4
      with:
        files: ${{ steps.coverage.outputs.coverage_file }}
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false
        token: ${{ secrets.CODECOV_TOKEN }}
        verbose: true
      continue-on-error: true
    
    - name: Upload Coverage Report Artifact
      if: always() && steps.coverage.outputs.has_coverage == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: ${{ runner.temp }}/CoverageReport
        if-no-files-found: ignore
        retention-days: 1

    - name: End SonarCloud Analysis
      if: env.SONAR_TOKEN != ''
      shell: pwsh
      run: |
        .\.sonar\scanner\dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"
      continue-on-error: true

  # Evaluation mode test - manual trigger only
  test-evaluation-mode:
    runs-on: windows-latest
    if: github.event_name == 'workflow_dispatch' && inputs.run_evaluation_mode == true
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Restore dependencies
      run: dotnet restore AsposeMcpServer.sln
    
    - name: Build
      run: dotnet build --configuration Release --no-restore
    
    - name: Test in Evaluation Mode
      run: |
        .\test.ps1 -SkipLicense -NoBuild
      continue-on-error: true
    
    - name: Upload evaluation mode test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-eval
        path: '**/test-results.trx'
        if-no-files-found: ignore
        retention-days: 1

